package generator

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-faster/errors"

	"github.com/jolfzverb/codegen/internal/generator/astbuilder"
)

type HandlersFile struct {
	requiredFieldsArePointers bool
	packageName               *ast.Ident
	interfaceDecls            []*ast.GenDecl

	/*
		handlerDecl            *ast.GenDecl
		handlerDeclQAFieldList *ast.FieldList // quick access to handler struct field list
	*/
	handlerDeclBuilder *astbuilder.StructBuilder

	handlerConstructorDecl                       *ast.FuncDecl
	handlerConstructorDeclQAArgs                 *ast.FieldList    // quick access to handler constructor args
	handlerConstructorDeclQAConstructorComposite *ast.CompositeLit // quick access to handler struct initializer

	addRoutesDecl         *ast.FuncDecl
	handleDeclQASwitches  map[string]*ast.BlockStmt
	restDecls             []*ast.FuncDecl
	hasContainsNullMethod bool
}

func (g *Generator) InitHandlerImports() {
	g.AddHandlersImport("github.com/go-playground/validator/v10")
	g.AddHandlersImport("github.com/go-chi/chi/v5")
}

func (g *Generator) InitHandlerStruct() {
	g.HandlersFile.handlerDeclBuilder = astbuilder.NewStructBuilder().WithName("Handler").
		AddField(astbuilder.NewFieldBuilder().WithName("validator").WithType(
			astbuilder.NewSimpleTypeBuilder().AddElements("validator", "Validate").AsPointer(true)))
}

func (g *Generator) InitHandlerConstructor() {
	initializerComposite := &ast.CompositeLit{
		Type: I("Handler"),
		Elts: []ast.Expr{
			&ast.KeyValueExpr{
				Key: I("validator"),
				Value: &ast.CallExpr{
					Fun: Sel(I("validator"), "New"),
					Args: []ast.Expr{
						&ast.CallExpr{
							Fun: Sel(I("validator"), "WithRequiredStructEnabled"),
						},
					},
				},
			},
		},
	}

	g.HandlersFile.handlerConstructorDecl = Func(
		"NewHandler",
		nil,
		nil,
		FieldA(Field("", Star(I("Handler")), "")),
		[]ast.Stmt{Ret1(Amp(initializerComposite))},
	)

	g.HandlersFile.handlerConstructorDeclQAArgs = g.HandlersFile.handlerConstructorDecl.Type.Params
	g.HandlersFile.handlerConstructorDeclQAConstructorComposite = initializerComposite
}

func (g *Generator) InitRoutesFunc() {
	g.HandlersFile.addRoutesDecl = Func(
		"AddRoutes",
		Field("h", Star(I("Handler")), ""),
		FieldA(Field("router", Sel(I("chi"), "Router"), "")),
		nil,
		[]ast.Stmt{},
	)
}

func (g *Generator) InitHandlerFields(packageName string) {
	g.HandlersFile.packageName = I(packageName)

	g.InitHandlerImports()

	g.InitHandlerStruct()

	g.InitHandlerConstructor()

	g.InitRoutesFunc()
}

func (g *Generator) NewHandlersFile() {
	g.HandlersFile = &HandlersFile{
		requiredFieldsArePointers: g.Opts.RequiredFieldsArePointers,
	}
}

func (g *Generator) WriteHandlersToOutput(output io.Writer) error {
	const op = "generator.HandlersFile.WriteToOutput"
	// go/ast package is great!
	_, err := output.Write([]byte("// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.\n\n"))
	if err != nil {
		return errors.Wrap(err, op)
	}

	file := g.GenerateHandlersFile()
	err = format.Node(output, token.NewFileSet(), file)
	if err != nil {
		return errors.Wrap(err, op)
	}

	return nil
}

func (g *Generator) AddHandlersInterface(name string, methodName string, requestName string, responseName string) {
	interfaceBuilder := astbuilder.NewInterfaceBuilder().WithName(name).WithMethod(
		astbuilder.NewInterfaceMethodBuilder().WithName(methodName).
			AddArgField(
				astbuilder.NewFieldBuilder().WithName("ctx").WithType(
					astbuilder.NewSimpleTypeBuilder().AddElements("context", "Context"),
				)).
			AddArgField(
				astbuilder.NewFieldBuilder().WithName("r").WithType(
					astbuilder.NewSimpleTypeBuilder().AddElements(
						g.GetCurrentModelsPackage(), requestName,
					))).
			AddRetvalField(
				astbuilder.NewFieldBuilder().WithType(
					astbuilder.NewSimpleTypeBuilder().AddElements(
						g.GetCurrentModelsPackage(), responseName,
					).AsPointer(true))).
			AddRetvalField(
				astbuilder.NewFieldBuilder().WithType(
					astbuilder.NewSimpleTypeBuilder().AddElement("error")),
			),
	)

	g.HandlersFile.interfaceDecls = append(g.HandlersFile.interfaceDecls, interfaceBuilder.Build())
}

func (g *Generator) AddDependencyToHandlers(baseName string) {
	fieldName := GoIdentLowercase(baseName)

	g.HandlersFile.handlerDeclBuilder.AddField(
		astbuilder.NewFieldBuilder().WithName(fieldName).WithType(
			astbuilder.NewSimpleTypeBuilder().AddElement(baseName + "Handler")))

	g.HandlersFile.handlerConstructorDeclQAArgs.List = append(g.HandlersFile.handlerConstructorDeclQAArgs.List,
		Field(fieldName, I(baseName+"Handler"), ""))

	g.HandlersFile.handlerConstructorDeclQAConstructorComposite.Elts = append(
		g.HandlersFile.handlerConstructorDeclQAConstructorComposite.Elts, &ast.KeyValueExpr{
			Key:   I(fieldName),
			Value: I(fieldName),
		},
	)
}

func (g *Generator) AddHandlersImport(path string) {
	g.HandlerImportsBuilder.AddImport(path)
}

func (g *Generator) GenerateHandlersFile() *ast.File {
	importSpecs, declSpecs := g.HandlerImportsBuilder.Build()

	g.FinalizeHandlerSwitches()

	file := &ast.File{
		Name:    g.HandlersFile.packageName,
		Decls:   []ast.Decl{},
		Imports: importSpecs,
	}

	file.Decls = append(file.Decls, &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: declSpecs,
	})
	for _, d := range g.HandlersFile.interfaceDecls {
		file.Decls = append(file.Decls, d)
	}

	file.Decls = append(file.Decls, g.HandlersFile.handlerDeclBuilder.BuildAsDeclaration())
	file.Decls = append(file.Decls, g.HandlersFile.handlerConstructorDecl)
	file.Decls = append(file.Decls, g.HandlersFile.addRoutesDecl)
	for _, d := range g.HandlersFile.restDecls {
		file.Decls = append(file.Decls, d)
	}

	return file
}

func (g *Generator) AddRouteToRouter(baseName string, method string, pathName string) {
	g.HandlersFile.addRoutesDecl.Body.List = append(g.HandlersFile.addRoutesDecl.Body.List, &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun: Sel(I("router"), method),
			Args: []ast.Expr{
				Str(pathName),
				Sel(I("h"), "handle"+baseName),
			},
		},
	})
}

func (g *Generator) GetHandler(baseName string) *ast.BlockStmt {
	if g.HandlersFile.handleDeclQASwitches == nil {
		return nil
	}
	if blockStmt, ok := g.HandlersFile.handleDeclQASwitches[baseName]; ok {
		return blockStmt
	}

	return nil
}

func (g *Generator) CreateHandler(baseName string) {
	switchBody := &ast.BlockStmt{
		List: []ast.Stmt{},
	}

	handleFunc := Func(
		"handle"+baseName,
		Field("h", Star(I("Handler")), ""),
		[]*ast.Field{
			Field("w", Sel(I("http"), "ResponseWriter"), ""),
			Field("r", Star(Sel(I("http"), "Request")), ""),
		},
		nil,
		[]ast.Stmt{
			&ast.SwitchStmt{
				Tag: &ast.CallExpr{
					Fun:  Sel(I("r.Header"), "Get"),
					Args: []ast.Expr{Str("Content-Type")},
				},
				Body: switchBody,
			},
		},
	)

	g.HandlersFile.restDecls = append(g.HandlersFile.restDecls, handleFunc)

	if g.HandlersFile.handleDeclQASwitches == nil {
		g.HandlersFile.handleDeclQASwitches = make(map[string]*ast.BlockStmt)
	}
	g.HandlersFile.handleDeclQASwitches[baseName] = switchBody
}

func (g *Generator) FinalizeHandlerSwitches() {
	if g.HandlersFile.handleDeclQASwitches == nil {
		return
	}
	for _, blockStmt := range g.HandlersFile.handleDeclQASwitches {
		blockStmt.List = append(blockStmt.List, &ast.CaseClause{
			List: nil,
			Body: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: Sel(I("http"), "Error"),
						Args: []ast.Expr{
							I("w"),
							Str("{\"error\":\"Unsupported Content-Type\"}"),
							Sel(I("http"), "StatusUnsupportedMediaType"),
						},
					},
				},
				Ret(),
			},
		})
	}
}

func (g *Generator) AddContentTypeHandler(baseName string, rawContentType string) {
	if g.HandlersFile.handleDeclQASwitches == nil {
		return
	}
	if blockStmt, ok := g.HandlersFile.handleDeclQASwitches[baseName]; ok {
		stmts := []ast.Stmt{
			&ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: Sel(I("h"), "handle"+baseName+"Request"),
					Args: []ast.Expr{
						I("w"),
						I("r"),
					},
				},
			},
			Ret(),
		}

		blockStmt.List = append(blockStmt.List, &ast.CaseClause{
			List: []ast.Expr{Str(rawContentType)},
			Body: stmts,
		},
		)

		if rawContentType == applicationJSONCT {
			blockStmt.List = append(blockStmt.List, &ast.CaseClause{
				List: []ast.Expr{Str("")},
				Body: stmts,
			})
		}
	}
}

func (g *Generator) AddHandleOperationMethodHandlers(baseName string) {
	g.HandlersFile.restDecls = append(g.HandlersFile.restDecls, Func(
		"handle"+baseName+"Request",
		Field("h", Star(I("Handler")), ""),
		[]*ast.Field{
			Field("w", Sel(I("http"), "ResponseWriter"), ""),
			Field("r", Star(Sel(I("http"), "Request")), ""),
		},
		nil,
		[]ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{
					I("request"),
					I("err"),
				},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: Sel(I("h"), "parse"+baseName+"Request"),
						Args: []ast.Expr{
							I("r"),
						},
					},
				},
			},
			&ast.IfStmt{
				Cond: Ne(I("err"), I("nil")),
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: Sel(I("http"), "Error"),
								Args: []ast.Expr{
									I("w"),
									&ast.CallExpr{
										Fun: Sel(I("fmt"), "Sprintf"),
										Args: []ast.Expr{
											Str("{\"error\":%s}"),
											&ast.CallExpr{
												Fun: Sel(I("strconv"), "Quote"),
												Args: []ast.Expr{
													&ast.CallExpr{
														Fun: Sel(I("err"), "Error"),
													},
												},
											},
										},
									},
									Sel(I("http"), "StatusBadRequest"),
								},
							},
						},
						Ret(),
					},
				},
			},
			&ast.AssignStmt{
				Lhs: []ast.Expr{
					I("ctx"),
				},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun:  Sel(I("r"), "Context"),
						Args: []ast.Expr{},
					},
				},
			},
			&ast.AssignStmt{
				Lhs: []ast.Expr{
					I("response"),
					I("err"),
				},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: Sel(Sel(I("h"), GoIdentLowercase(baseName)), "Handle"+baseName),
						Args: []ast.Expr{
							I("ctx"),
							Star(I("request")),
						},
					},
				},
			},
			&ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X:  Ne(I("err"), I("nil")),
					Op: token.LOR,
					Y:  Eq(I("response"), I("nil")),
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: Sel(I("http"), "Error"),
								Args: []ast.Expr{
									I("w"),
									Str("{\"error\":\"InternalServerError\"}"),
									Sel(I("http"), "StatusInternalServerError"),
								},
							},
						},
						Ret(),
					},
				},
			},
			&ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: Sel(I("h"), "write"+baseName+"Response"),
					Args: []ast.Expr{
						I("w"),
						I("response"),
					},
				},
			},
			Ret(),
		},
	))
	g.AddHandlersImport("fmt")
	g.AddHandlersImport("strconv")
}

func (g *Generator) AddWriteResponseMethodHandlers(baseName string, codes []string, operation *openapi3.Operation) error {
	switchBody := &ast.BlockStmt{
		List: []ast.Stmt{},
	}
	for _, code := range codes {
		response := operation.Responses.Value(code)

		caseBody := []ast.Stmt{}
		caseBody = append(caseBody, &ast.IfStmt{
			Cond: Eq(Sel(I("response"), "Response"+code), I("nil")),
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun: Sel(I("http"), "Error"),
							Args: []ast.Expr{
								I("w"),
								Str("{\"error\":\"InternalServerError\"}"),
								Sel(I("http"), "StatusInternalServerError"),
							},
						},
					},
					Ret(),
				},
			},
		})

		if len(response.Value.Headers) > 0 {
			caseBody = append(caseBody,
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: Sel(I("h"), "write"+baseName+code+"ResponseHeaders"),
						Args: []ast.Expr{
							I("w"),
							Sel(I("response"), "Response"+code),
						},
					},
				})
		}

		if len(response.Value.Content) > 0 {
			if len(response.Value.Content) > 1 {
				return errors.New("multiple content types are not supported for response code " + code)
			}
			var contentType string
			for key := range response.Value.Content {
				contentType = key
				break
			}
			caseBody = append(caseBody,
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: Sel(&ast.CallExpr{
							Fun:  Sel(I("w"), "Header"),
							Args: []ast.Expr{},
						}, "Set"),
						Args: []ast.Expr{
							Str("Content-Type"),
							Str(g.getContentTypeHeadeValue(contentType)),
						},
					},
				},
			)

		}

		caseBody = append(caseBody, &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun:  Sel(I("w"), "WriteHeader"),
				Args: []ast.Expr{Sel(I("response"), "StatusCode")},
			},
		})
		caseBody = append(caseBody, &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: Sel(I("h"), "write"+baseName+code+"Response"),
				Args: []ast.Expr{
					I("w"),
					Sel(I("response"), "Response"+code),
				},
			},
		})
		caseBody = append(caseBody, &ast.ReturnStmt{})
		switchBody.List = append(switchBody.List, &ast.CaseClause{
			List: []ast.Expr{
				&ast.BasicLit{
					Kind:  token.INT,
					Value: code,
				},
			},
			Body: caseBody,
		})
	}

	writeResponseFunc := Func(
		"write"+baseName+"Response",
		Field("h", Star(I("Handler")), ""),
		[]*ast.Field{
			Field("w", Sel(I("http"), "ResponseWriter"), ""),
			Field("response", Star(Sel(I(g.GetCurrentModelsPackage()), baseName+"Response")), ""),
		},
		nil,
		[]ast.Stmt{
			&ast.SwitchStmt{
				Tag:  Sel(I("response"), "StatusCode"),
				Body: switchBody,
			},
			&ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: Sel(I("http"), "Error"),
					Args: []ast.Expr{
						I("w"),
						Str("{\"error\":\"InternalServerError\"}"),
						Sel(I("http"), "StatusInternalServerError"),
					},
				},
			},
		},
	)

	g.HandlersFile.restDecls = append(g.HandlersFile.restDecls, writeResponseFunc)
	return nil
}

func (g *Generator) getContentTypeHeadeValue(contentType string) string {
	textualContentType := map[string]struct{}{
		"text/plain":             {},
		"text/html":              {},
		"text/css":               {},
		"application/javascript": {},
		"application/xml":        {},
		"application/json":       {},
	}
	if _, ok := textualContentType[contentType]; ok {
		return fmt.Sprintf("%s; charset=utf-8", contentType)
	}
	return contentType
}

func (g *Generator) AddWriteHeadersForResponseCode(baseName string, code string, response *openapi3.ResponseRef) error {
	var body []ast.Stmt

	g.AddHandlersImport("encoding/json")
	body = append(body, &ast.AssignStmt{
		Lhs: []ast.Expr{
			I("headersJSON"),
			I("err"),
		},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun:  Sel(I("json"), "Marshal"),
				Args: []ast.Expr{Sel(I("r"), "Headers")},
			},
		},
	})
	body = append(body, &ast.IfStmt{
		Cond: Ne(I("err"), I("nil")),
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: Sel(I("http"), "Error"),
						Args: []ast.Expr{
							I("w"),
							Str("{\"error\":\"InternalServerError\"}"),
							Sel(I("http"), "StatusInternalServerError"),
						},
					},
				},
				Ret(),
			},
		},
	})
	body = append(body, &ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok: token.VAR,
			Specs: []ast.Spec{
				&ast.ValueSpec{
					Names: []*ast.Ident{I("headers")},
					Type: &ast.MapType{
						Key:   I("string"),
						Value: I("string"),
					},
				},
			},
		},
	})
	body = append(body, &ast.AssignStmt{
		Lhs: []ast.Expr{I("err")},
		Tok: token.ASSIGN,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun: Sel(I("json"), "Unmarshal"),
				Args: []ast.Expr{
					I("headersJSON"),
					Amp(I("headers")),
				},
			},
		},
	})
	body = append(body, &ast.IfStmt{
		Cond: Ne(I("err"), I("nil")),
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: Sel(I("http"), "Error"),
						Args: []ast.Expr{
							I("w"),
							Str("{\"error\":\"InternalServerError\"}"),
							Sel(I("http"), "StatusInternalServerError"),
						},
					},
				},
				Ret(),
			},
		},
	})
	body = append(body, &ast.RangeStmt{
		Key:   I("key"),
		Value: I("value"),
		Tok:   token.DEFINE,
		X:     I("headers"),
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: Sel(&ast.CallExpr{
							Fun:  Sel(I("w"), "Header"),
							Args: []ast.Expr{},
						}, "Set"),
						Args: []ast.Expr{
							I("key"),
							I("value"),
						},
					},
				},
			},
		},
	})

	writeResponseFunc := Func(
		"write"+baseName+code+"ResponseHeaders",
		Field("h", Star(I("Handler")), ""),
		[]*ast.Field{
			Field("w", Sel(I("http"), "ResponseWriter"), ""),
			Field("r", Star(Sel(I(g.GetCurrentModelsPackage()), baseName+"Response"+code)), ""),
		},
		nil,
		body,
	)

	g.HandlersFile.restDecls = append(g.HandlersFile.restDecls, writeResponseFunc)

	return nil
}

func (g *Generator) AddWriteResponseCode(baseName string, code string, response *openapi3.ResponseRef) error {
	var body []ast.Stmt

	if len(response.Value.Content) > 1 {
		return errors.New("multiple responses are not supported")
	}
	for key, value := range response.Value.Content {
		if key != applicationJSONCT {
			return errors.New("only application/json content type is supported")
		}
		if value.Schema != nil {
			g.AddHandlersImport("encoding/json")
			body = append(body, &ast.AssignStmt{
				Lhs: []ast.Expr{I("err")},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: Sel(&ast.CallExpr{
							Fun:  Sel(I("json"), "NewEncoder"),
							Args: []ast.Expr{I("w")},
						}, "Encode"),

						Args: []ast.Expr{Sel(I("r"), "Body")},
					},
				},
			})
			body = append(body, &ast.IfStmt{
				Cond: Ne(I("err"), I("nil")),
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: Sel(I("http"), "Error"),
								Args: []ast.Expr{
									I("w"),
									Str("{\"error\":\"InternalServerError\"}"),
									Sel(I("http"), "StatusInternalServerError"),
								},
							},
						},
						Ret(),
					},
				},
			})
		}
	}

	if len(body) > 0 {
		body = append([]ast.Stmt{&ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: []*ast.Ident{I("err")},
						Type:  I("error"),
					},
				},
			},
		}}, body...)
	}

	writeResponseFunc := Func(
		"write"+baseName+code+"Response",
		Field("h", Star(I("Handler")), ""),
		[]*ast.Field{
			Field("w", Sel(I("http"), "ResponseWriter"), ""),
			Field("r", Star(Sel(I(g.GetCurrentModelsPackage()), baseName+"Response"+code)), ""),
		},
		nil,
		body,
	)

	g.HandlersFile.restDecls = append(g.HandlersFile.restDecls, writeResponseFunc)

	return nil
}

func (g *Generator) AddParsePathParamsMethod(baseName string, params openapi3.Parameters) error {
	bodyList := []ast.Stmt{
		&ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: []*ast.Ident{I("pathParams")},
						Type:  Sel(I(g.GetCurrentModelsPackage()), baseName+"PathParams"),
					},
				},
			},
		},
	}

	for _, param := range params {
		if param.Value.Schema == nil || param.Value.Schema.Value == nil {
			continue
		}

		varName := GoIdentLowercase(FormatGoLikeIdentifier(param.Value.Name))
		bodyList = append(bodyList, &ast.AssignStmt{
			Lhs: []ast.Expr{I(varName)},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun:  Sel(I("chi"), "URLParam"),
					Args: []ast.Expr{I("r"), Str(param.Value.Name)},
				},
			},
		})
		bodyList = append(bodyList, &ast.IfStmt{
			Cond: Eq(I(varName), Str("")),
			Body: &ast.BlockStmt{
				List: []ast.Stmt{Ret2(I("nil"),
					&ast.CallExpr{
						Fun:  Sel(I("errors"), "New"),
						Args: []ast.Expr{Str(param.Value.Name + " path param is required")},
					},
				)},
			},
		})
		g.AddHandlersImport("github.com/go-faster/errors")
		switch {
		case param.Value.Schema.Value.Type.Permits("string"):
			bodyList = append(bodyList, &ast.AssignStmt{
				Lhs: []ast.Expr{Sel(I("pathParams"), FormatGoLikeIdentifier(param.Value.Name))},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{
					I(varName),
				},
			})
		default:
			return errors.New(fmt.Sprintf("unsupported path parameter type: %v", param.Value.Schema.Value.Type)) //nolint:revive
		}
	}

	bodyList = append(bodyList, &ast.AssignStmt{
		Lhs: []ast.Expr{I("err")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun: Sel(Sel(I("h"), "validator"), "Struct"),
				Args: []ast.Expr{
					I("pathParams"),
				},
			},
		},
	})
	bodyList = append(bodyList, &ast.IfStmt{
		Cond: Ne(I("err"), I("nil")),
		Body: &ast.BlockStmt{List: []ast.Stmt{Ret2(I("nil"), I("err"))}},
	})
	bodyList = append(bodyList, Ret2(Amp(I("pathParams")), I("nil")))

	parsePathParamsFunc := Func(
		"parse"+baseName+"PathParams",
		Field("h", Star(I("Handler")), ""),
		[]*ast.Field{
			Field("r", Star(Sel(I("http"), "Request")), ""),
		},
		[]*ast.Field{
			Field("", Star(Sel(I(g.GetCurrentModelsPackage()), baseName+"PathParams")), ""),
			Field("", I("error"), ""),
		},
		bodyList,
	)

	g.HandlersFile.restDecls = append(g.HandlersFile.restDecls, parsePathParamsFunc)

	return nil
}
